// ignore_for_file: avoid_print

import 'dart:async';
import 'dart:io';

import 'package:approval_tests/approval_tests.dart';
import 'package:approval_tests_flutter/src/common.dart';
import 'package:approval_tests_flutter/src/get_widget_names.dart';
import 'package:approval_tests_flutter/src/widget_meta/collect_widgets_meta_data.dart' as widgets_meta_data;
import 'package:flutter_test/flutter_test.dart';

Set<String>? _widgetNames;
final _executedApprovedFullPaths = <String>{};
bool _allTestsPassed = true;

class ApprovalWidgets {
  /// Initializes the approval test by building a database of project classes.
  ///
  /// Typically called from within flutter_tests function 'setUpAll'
  static Future<Set<String>> setUpAll() async {
    final completer = Completer<Set<String>>();
    await getWidgetNames().then((value) {
      _widgetNames = value;
      completer.complete(value);
    });
    return completer.future;
  }

  /// Performs checks after testing is complete.
  ///
  /// Checks performed
  /// - If all tests passed, it confirms there are no unnecessary .approved.txt or .unapproved.txt files hanging around.
  static Future<void> tearDownAll() async {
    if (!_allTestsPassed) return;

    final testPath = _testFilePath();
    final testDirectory = Directory(testPath);
    final approvedFullPaths =
        testDirectory.filesWithExtension('.${Namer.approvedExtension}').map((file) => file.path).toSet();
    final unapprovedFullPaths =
        testDirectory.filesWithExtension('.${Namer.receivedExtension}').map((file) => file.path).toSet();

    for (final approvedFullPath in _executedApprovedFullPaths) {
      if (approvedFullPaths.contains(approvedFullPath)) {
        approvedFullPaths.remove(approvedFullPath);
      }
      final unapprovedFullPath = approvedFullPath.replaceAll(Namer.approvedExtension, Namer.receivedExtension);
      if (unapprovedFullPaths.contains(unapprovedFullPath)) {
        unapprovedFullPaths.remove(unapprovedFullPath);
      }
    }

    if (approvedFullPaths.isNotEmpty || approvedFullPaths.isNotEmpty) {
      print('''
topBar 
    The files listed below were generated by approvalTest but are no longer used:\n''');
      for (final approvedFullPath in approvedFullPaths) {
        print('    $approvedFullPath');
      }
      for (final unapprovedFullPath in unapprovedFullPaths) {
        print('    $unapprovedFullPath');
      }
      print(bottomBar);
    }

    final completer = Completer<void>();
    await getWidgetNames().then((value) {
      _widgetNames = value;
      completer.complete(null);
    });
    return completer.future;
  }

  static Set<String>? get widgetNames => _widgetNames;
}

/// [_globalApprovalTest] resolves the name conflict with [WidgetTester.approvalTest]
Future<void> Function(String?, String) _globalApprovalTest = (description, value) async {
  Approvals.verify(
    value,
    options: Options(
      namer: Namer(
        description: description,
      ),
    ),
  );
};

extension WidgetTesterApprovedExtension on WidgetTester {
  /// Returns the meta data for the widgets for comparison during the approval test
  Future<String> get widgetsString async {
    final completer = Completer<String>();
    assert(_widgetNames != null, '''
$topBar
    Looks like Approved.initialize() was not called before running an approvalTest. Typically, 
    this issue is solved by calling Approved.initialize() from within setUpAll:
    
        void setUpAll(() async {
          await Approved.initialize();
        });
$bottomBar''');

    await widgets_meta_data
        .collectWidgetsMetaData(
      this,
      outputMeta: true,
      verbose: false,
      widgetNames: ApprovalWidgets.widgetNames,
    )
        .then((stringList) {
      completer.complete(stringList.join('\n'));
    });

    return completer.future;
  }

  /// Performs an approval test.
  ///
  /// [description] is the name of the test. It is appended to the description in [Tester].
  /// [textForReview] is the meta data text used in the approval test.
  Future<void> approvalTest([String? description, String? textForReview]) async {
    final resultCompleter = Completer<void>();
    final widgetsMetaCompleter = Completer<String>();
    final String updatedTestDescription = description == null ? testDescription : '$testDescription $description';

    // Get the test path before the stack gets too deep.
    _testFilePath();

    // If no text passed, then get the widget meta from the widget tree
    if (textForReview == null) {
      await widgetsString.then((value) {
        widgetsMetaCompleter.complete(value);
      });
    } else {
      widgetsMetaCompleter.complete(textForReview);
    }
    await widgetsMetaCompleter.future.then((value) {
      resultCompleter.complete(_globalApprovalTest(updatedTestDescription, value));
    });
    return resultCompleter.future;
  }

  /// Output expect statements to the console.
  Future<void> printExpects() => widgets_meta_data.printExpects(this);
}

/// Typically, .approved.txt files are stored alongside the flutter test file. However, there may be edge cases
/// where the path to the test cannot be determined because the stack is too deep. If so, create a local path for
/// storing .approved.txt
String _previousTestFilePath = './test/approved';

/// The path to the consumer's '..._test.dart' file that is executing the test
///
/// Search the stacktrace from the calling ..._test.dart. If the file is not found, a previous path is used.
/// (This should never happen, but the logic is here just in case to prevent files written to the root directory.)
String _testFilePath() {
  String? result;

  final stackTrace = StackTrace.current;
  final lines = stackTrace.toString().split('\n');
  final pathLine = lines.firstWhere((line) => line.contains('_test.dart'), orElse: () => '');

  if (pathLine.isNotEmpty) {
    final match = RegExp(r'\(file:\/\/(.*\/)').firstMatch(pathLine);
    if (match != null && match.groupCount > 0) {
      result = Uri.parse(match.group(1)!).toFilePath();
      result = result.endsWith('/') ? result.substring(0, result.length - 1) : result;
    }
  }

  // If result is null, then "..._test.dart" filename not found, likely because stack was too deep, so use previous path.
  if (result == null) {
    result = _previousTestFilePath;
    // make sure the path exists (e.g., could be "./approved")
    final dir = Directory(result);
    if (!dir.existsSync()) {
      dir.createSync();
    }
  } else {
    _previousTestFilePath = result;
  }

  return result;
}
