import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:analyzer/dart/analysis/context_builder.dart';
import 'package:analyzer/dart/analysis/context_locator.dart';
import 'package:analyzer/dart/analysis/results.dart';
import 'package:analyzer/dart/ast/ast.dart';
import 'package:approval_tests/approval_tests.dart';
import 'package:approval_tests_flutter/src/common.dart';

final _widgetNamesDir = Directory(ApprovalTestsConstants.resourceLocalPath);
final _widgetNamesPath = '${_widgetNamesDir.path}/class_names.txt';

Future<Set<String>> getWidgetNames() async {
  final resultCompleter = Completer<Set<String>>();

  await isWidgetNamesFileFresh().then((isFileFresh) {
    if (isFileFresh) {
      readWidgetsFile(_widgetNamesPath).then((widgetNames) {
        resultCompleter.complete(widgetNames);
      });
    } else {
      final libPath = '${Directory.current.absolute.path}/lib';
      stdout
          .write("package:approved: searching for class names in $libPath...");
      extractWidgetNames(libPath).then((widgetsList) {
        if (!_widgetNamesDir.existsSync()) {
          _widgetNamesDir.createSync();
        }
        _widgetNamesDir.createSync();
        final widgetsFile = File(_widgetNamesPath);
        widgetsFile.createSync();
        const header = '''
# This file was autogenerated by package:approved. Please do not edit.
# Below is a list of class found in the project /lib folder.''';
        final widgetNamesString = widgetsList.join('\n').endWithNewline;
        widgetsFile.writeAsStringSync('$header\n$widgetNamesString');
        stdout.write('done\n');
        resultCompleter.complete(widgetsList);
      });
    }
  });

  return resultCompleter.future;
}

String loadWidgetNames() {
  late String result;
  final widgetNamesFile = File(_widgetNamesPath);
  if (widgetNamesFile.existsSync()) {
    result = widgetNamesFile.readAsStringSync();
  }
  return result;
}

/// Crawls the project and extracts widget names.
Future<Set<String>> extractWidgetNames(String libPath) async {
  final completer = Completer<Set<String>>();

  final contextLocator = ContextLocator();
  final contextRoots = contextLocator.locateRoots(includedPaths: [libPath]);

  final contextBuilder = ContextBuilder();
  await getFlutterSdkPath().then((path) {
    final dartStr = '$path/bin/cache/dart-sdk';
    final analysisContext = contextBuilder.createContext(
      contextRoot: contextRoots.first,
      sdkPath: dartStr,
    );

    final classNames = <String>{};

    // Traverse all files in the lib folder
    final libDirectory = Directory(libPath);
    final dartFiles = libDirectory.listSync(recursive: true).where(
          (file) =>
              file.path.endsWith('.dart') &&
              !file.path.contains('.g.dart') &&
              !file.path.contains('.freezed.dart'),
        );

    for (final file in dartFiles) {
      final analysisSession = analysisContext.currentSession;
      final parsedResult =
          analysisSession.getParsedUnit(file.path) as ParsedUnitResult;

      for (final compilationUnitMember in parsedResult.unit.declarations) {
        if (compilationUnitMember is ClassDeclaration) {
          final String name = compilationUnitMember.name.value().toString();
          if (!name.startsWith('_')) {
            classNames.add(name);
          }
        }
      }
    }

    completer.complete(classNames);
  });

  return completer.future;
}

/// Get the path to the Flutter SDK
Future<String> getFlutterSdkPath() async {
  final completer = Completer<String>();

  await Process.run('flutter', ['--version', '--machine']).then((result) {
    if (result.exitCode != 0) {
      throw Exception('Failed to run flutter command: ${result.stderr}');
    }

    final jsonData =
        jsonDecode(result.stdout.toString()) as Map<String, dynamic>;

    completer.complete(jsonData['flutterRoot'].toString());
  });

  return completer.future;
}

Future<Set<String>> readWidgetsFile(String filePath) async {
  final completer = Completer<Set<String>>();
  final File file = File(filePath);

  await file.readAsString().then((text) {
    // Split by lines
    final linesList = text.split('\n');
    // Remove empty lines and comments
    final linesSet = linesList
        .where((line) => line.isNotEmpty && !line.startsWith('#'))
        .toSet();
    completer.complete(linesSet);
  });

  return completer.future;
}

Future<bool> isWidgetNamesFileFresh() async {
  final resultCompleter = Completer<bool>();

  final libDirectory = Directory('lib');

  await findNewestDartFileTimestamp(libDirectory).then((dateTime) {
    final widgetNamesFile = File(_widgetNamesPath);
    if (dateTime != null &&
        widgetNamesFile.existsSync() &&
        widgetNamesFile.lastModifiedSync().isAfter(dateTime)) {
      resultCompleter.complete(true);
    } else {
      resultCompleter.complete(false);
    }
  });

  return resultCompleter.future;
}

Future<DateTime?> findNewestDartFileTimestamp(Directory dir) async {
  DateTime? newestTimestamp;

  if (!await dir.exists()) {
    return null;
  }

  await for (final FileSystemEntity entity in dir.list(recursive: true)) {
    if (entity is File && entity.path.endsWith('.dart')) {
      final DateTime lastModified = await entity.lastModified();

      if (newestTimestamp == null || lastModified.isAfter(newestTimestamp)) {
        newestTimestamp = lastModified;
      }
    }
  }

  return newestTimestamp;
}
